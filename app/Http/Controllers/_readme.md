Так как в архитектуре проекта используются следующая структура

```text
UseCases/
    /Commands
        /{Домен}
    /Queries
        /{Домен}
```

Нельзя адекватно реализовать вызов команд и запросов в одном контроллере, так как происходит следующее

```php

use Illuminate\Http\Request
use App\UseCases\Commands\Auth\Register

/** 
 * По хорошему должно быть так
 */ 
class AuthController
{
    public function register(Request $request, CommandHandler $handler)
    {
        return $handler->handle(
            Command::fillAttributes($request->all())
        )
    }
    
    /** 
     * Проблема в том что у нас название команд и хендлеров одинковое, 
     * тем самым мы не можем просто взять и вызвать таким образом 
     */
}

/** 
 * Есть два решения!
 *
 * 1) Импорт через namespace
 * 2) invoke контроллеры 
 * 
 * Рассмотрим первый вариант
 */
 
use App\UseCases\Commands\Auth as CommandsUseCases
use App\UseCases\Queries\Auth as QueriesUseCases
 
class AuthController
{
    public function register(
        Request $request,
        CommandsUseCases\Register\CommandHandler $handler
    )
    {
        return $handler->handle(
            CommandsUseCases\Register\Command::fillAttributes(
                $request->all()
            )
        )
    }
    
    /** 
     * Код получается не очень то читабельным 
     * и не думаю что импорт через неймспейсы хорошее решение
     */
}

/** 
 * Второй же вариант с invoke классами 
 * 
 * Сематически код тоже будет разделяться 
 * по доменам в директории контроллеров
 * 
 * App/Http/Controllers/Api/Auth/
 *          - RegisterController
 *          - LoginController
 * 
 * В роуте регистрируем максимально просто
 * 
 * Route::prefix('auth')->group(function () {
        Route::post('/register', RegisterController::class)    
 * })
 * 
 * Сам же контроллер реализуем следующим образом
 */

use App\UseCases\Commands\Auth\Register\Command;
use App\UseCases\Commands\Auth\Register\CommandHandler;
use Illuminate\Http\Request;
use Thumbrise\Toolkit\Opresult\OperationResult;

class RegisterController extends Controller
{
    public function __invoke(
        Request $request,
        CommandHandler $handler
    ): OperationResult
    {
        return $handler->handle(
            Command::fillAttributes(
                $request->all()
            )
        );
    }
    
    /** 
     * Таким образом у нас нет проблем с импортами и 
     * использованием разных команд.
     * 
     * И так же мы получаем преимущества в виде:
     * 
     * 1. Четкое Разделение Ответственности
     * Invoke-контроллеры, каждый из которых выполняет 
     * одно конкретное действие, способствуют более 
     * четкому разделению ответственности. Это упрощает
     * понимание того, что делает каждый контроллер, 
     * и облегчает навигацию по коду.
     * 
     * 2. Простота и Минимализм
     * акие контроллеры упрощают структуру кода, 
     * так как каждый контроллер содержит минимальное 
     * количество логики, фокусируясь на одном действии. 
     * Это делает код более лаконичным и легким для чтения.
     * 
     * 3. Удобство Инъекции Зависимостей
     * Invoke-контроллеры легко использовать с инъекцией 
     * зависимостей, так как каждый класс может получить
     * необходимые зависимости через конструктор. Это 
     * способствует более чистому коду и упрощает тестирование.
     * 
     * 4. Упрощение Тестирования
     * Одноэкшнные контроллеры легче тестировать, 
     * так как каждый класс имеет только один метод,
     * что уменьшает количество комбинаций тестовых 
     * сценариев. Это также способствует лучшей изоляции 
     * тестов и повышает их надежность.
     * 
     * 5. Поддержка SOLID Принципов
     * Invoke-контроллеры способствуют применению 
     * принципов SOLID, особенно принципов единственной 
     * ответственности (Single Responsibility Principle) 
     * и открытости/закрытости (Open/Closed Principle). 
     * Они упрощают модификацию системы, так как добавление
     * нового действия требует создания нового контроллера, 
     * а не модификации существующего.
     * (Если я правильно всё понимаю) 
     * 
     * 6. Легкость Поддержки и Рефакторинга
     * Когда каждое действие вынесено в отдельный контроллер,
     * легче поддерживать и модифицировать код. Добавление, 
     * удаление или изменение поведения одного действия не влияет
     * на другие действия, что уменьшает вероятность возникновения 
     * ошибок при рефакторинге.
     * 
     * 7. Организация и Структура
     * Использование отдельных классов для каждого
     * действия помогает в организации и структурировании 
     * кода, особенно в больших проектах. Это облегчает 
     * понимание структуры приложения и быстроту поиска 
     * нужного кода.  
     */
}
```